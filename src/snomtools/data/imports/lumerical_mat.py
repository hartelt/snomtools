"""
This scripts imports matlab files generated by the lumerical data export scripts. The methods defined here will read
those files and return the data as a DataSet instances. There might be different methods for different simulation
types.

"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
import snomtools.data.datasets
import snomtools.calcs.units as u
import h5py
import os
import numpy
import sys
import warnings

__author__ = 'hartelt'

if '-v' in sys.argv:
	verbose = True
else:
	verbose = False


def Efield_3d(filepath, first_coord='l', second_coord='y', third_coord='x', first_unit='m', second_unit='m',
			  third_unit='m', complex_=True):
	"""
	Reads a matlab file where the electric field of a frequency or time domain monitor stored in a grid coordinate system of
	three coordinates. The components Ex, Ey, Ez and the Intensity E^2 are included.
	CAUTION! The right order of the axes cannot be checked. This means the coordinates have to be given in the same
	order as the corresponding values are stored in the electric field arrays!

	:param filepath: String: The (absolute or relative) path of input file.

	:param first_coord: String: The label of the first coordinate, by default 'l' (for lambda).

	:param second_coord: String: The label of the second coordinate, by default 'y'.

	:param third_coord: String: The label of the third coordinate, by default 'x'.

	:param complex_: Boolean: Set to True for frequency domain monitor (default), set to False for time domain monitor.

	:return: The DataSet instance.
	"""
	warnings.warn("Efield_3d is depreciated. Use more general EMfield_3d instead!", DeprecationWarning)
	axes = [first_coord, second_coord, third_coord]
	keys = ['E2', 'Ex', 'Ey', 'Ez']
	return EMfield_3d(filepath, axes, first_unit, second_unit, keys)


def EMfield_3d(filepath, axes=None, unit_light=None, unit_space="um", field_keys=None, h5target=True):
	"""
	Reads a matlab file where the electric and/or magnetic field of a frequency or time domain monitor stored in a grid
	coordinate system of three coordinates. The x/y/z-components as well as ||^2 of E-Field, H-Field and Poynting Vector
	are read if present and properly named. Lookup keys in the .mat file are
	:code:`'E2','Ex','Ey','Ez','H2','Hx','Hy','Hz','P2','Px','Py','Pz'`
	CAUTION! The right order of the spatial axes are not be checked if given.
	This means the coordinates have to be given in the same order as the corresponding values are stored in the
	electric field arrays! Lumerical outputs them in order z,y,x.

	:param filepath: str: The (absolute or relative) path of input file.

	:param axes: optional: List or tuple of axis keys to be read.
	If not given, axes are detected automatically by the keys present in the .mat file.
	For a frequency-domain monitor, wavelength (lambda, :code:`l`) is chosen over frequency frequency (:code:`f`)
	per default if both are present.
	Frequency can be chosen by setting this parameter.
	Example: `axes = ['f','z','x']`

	:param unit_light: str, optional: Set the output unit for the first axis, concerning the light.
	Defaults are femtoseconds for time, nanometers for wavelength and terahertz for frequency.
	Read data for values of the first axis is converted to this unit.

	:param unit_space: str, optional: Set the output unit for the second and third axis, concerning the position.
	Defaults are micrometers.
	Read data for values of the x/y/z axis is converted to this unit.

	:param field_keys: optional: List or tuple of field keys to be read.
	If not given, keys are detected automatically by the keys present in the .mat file.
	For possible keys, see "lookup keys" above. Incompatible or absent keys given are ignored.
	Example: `field_keys = ['E2','Ex','Ey','Ez']` to read only Electric Field.
	Warning: If only incompatible keys, or keys not present in the .mat file are given, the DataSet consistency check
	will fail and and exception will be thrown.

	:param h5target: Optional: HDF5 Group or File to store read data in.
	Default is :code:`True` for working on a temporary file.
	Numpy-operation in RAM can be set by setting this to :code:`False`.
	:type h5target: h5py Group/File

	:return: The DataSet instance.
	"""
	# Initialize the input file object:
	filepath = os.path.abspath(filepath)
	if verbose:
		print("Opening Lumerical matlab export file: {0}".format(filepath))
	infile = h5py.File(filepath, 'r')

	# Axes to detect:
	possible_axes_first = ['l', 'f', 't']
	possible_axes_space = ['z', 'y', 'x']
	possible_axes = possible_axes_first + possible_axes_space

	# Axis units:
	def ax_inunit(ax):
		if ax in possible_axes_space:
			return 'm'
		elif ax == 't':
			return "s"
		elif ax == 'l':
			return "m"
		elif ax == 'f':
			return "Hz"

	def ax_outunit(ax):
		if ax in possible_axes_space:
			return unit_space
		elif ax in possible_axes_first and unit_light is not None:
			return unit_light
		elif ax == 't':
			return "fs"
		elif ax == 'l':
			return "nm"
		elif ax == 'f':
			return "THz"

	# Define labels:
	field_label_dict = {'E2': 'Electric Field Intensity / arb. unit',
						'Ex': 'E_x / arb. unit',
						'Ey': 'E_y / arb. unit',
						'Ez': 'E_z / arb. unit',
						'H2': 'Magnetic Field Intensity / arb. unit',
						'Hx': 'H_x / arb. unit',
						'Hy': 'H_y / arb. unit',
						'Hz': 'H_z / arb. unit',
						'P2': 'Poynting Vector Absolute Squared / arb. unit',
						'Px': 'P_x / arb. unit',
						'Py': 'P_y / arb. unit',
						'Pz': 'P_z / arb. unit'}
	ax_label_dict = {'l': 'Wavelength / ' + u.latex_si(ax_outunit('l')),
					 'f': 'Light Frequency / ' + u.latex_si(ax_outunit('f')),
					 't': 'Time / ' + u.latex_si(ax_outunit('t')),
					 'x': 'x / ' + u.latex_si(ax_outunit('x')),
					 'y': 'y / ' + u.latex_si(ax_outunit('y')),
					 'z': 'z / ' + u.latex_si(ax_outunit('z'))}

	# List fields to read:
	if field_keys is None:
		field_keys = field_label_dict.keys()

	# Detect axes:
	if axes is None:
		for ax in possible_axes_first:
			if ax in infile.keys():
				axes = [ax]
				break
		for ax in possible_axes_space:
			if ax in infile.keys():
				axes.append(ax)
	else:
		assert (axes[0] in possible_axes_first and axes[0] in infile.keys()), "Given first axis not valid."
		assert (axes[1] in possible_axes_space and axes[1] in infile.keys()), "Given second axis not valid"
		assert (axes[2] in possible_axes_space and axes[2] in infile.keys()), "Given third axis not valid"
	assert (len(axes) == 3), "Invalid number of axes given or detected. 3D EMfield needs three axes."
	# Check if frequency or time monitor data is read, adjust number format of field quantities accordingly:
	if axes[0] == 't':  # Time monitor means real fields.
		complex_ = False
	else:  # Frequency monitor means complex fields.
		complex_ = True

	if verbose:
		print("Given or detected axes keys are: ", axes)

	# Initialize the dataset. Data consistency (dimension and shape) will be checked by the init of DataSet:
	dataarrays = []
	for component in field_keys:
		if component in infile.keys():
			if verbose:
				print("Reading data for field component: {0}".format(component))
			if complex_ and not component.endswith('2'):  # If field quantity is complex:
				data = numpy.array(infile[component]).view(numpy.complex)
			else:
				data = infile[component]
			dataarrays.append(snomtools.data.datasets.DataArray(data, label=component,
																plotlabel=field_label_dict[component],
																h5target=True))
	out_axes = []
	if verbose:
		print("Reading Axes Data...")
	for ax in axes:
		axis = snomtools.data.datasets.Axis(infile[ax], unit=ax_inunit(ax), label=ax)
		axis.set_unit(ax_outunit(ax))
		axis.set_plotlabel(ax_label_dict[ax])
		out_axes.append(axis)
	if verbose:
		print("Generating and returning DataSet...")
	return snomtools.data.datasets.DataSet(os.path.basename(filepath), dataarrays, out_axes, h5target=h5target)


if False:  # Just for testing
	infile = "2015-08-03-Sphere4-substrate-532nm-bottomfieldE.mat"
	outfile = infile.replace('.mat', '.hdf5')
	dataset = Efield_3d(infile)
	dataset.saveh5(outfile)
